Сделаю тебе понятное описание, чтобы не лазить каждый раз по этим адским html-кам.

Ниже аккуратный конспект того, **как 1С ходит в ELMA** и **что за API там вообще есть**.

---

## 1. Общая схема работы с API ELMA

По коду модуля обмена картинка такая:

1. В 1С есть **параметры подключения** к ELMA (доп. константы):
   `АдресСервера`, `ПортСервера`, `ИмяПользователя`, `Пароль`, `ТокенПриложения`, `Таймаут`, `ИспользоватьЗащищенноеСоединение`.
2. 1С делает **авторизацию** в ELMA и получает `AuthToken`.
3. В регистре сведений `ПЛ_ОчередьОтправкиЗапросовВELMA` лежат задания:

   * `УИД1С` (ссылка на объект в 1С),
   * `IDРесурса` (строка с REST-путем ELMA),
   * `ОбъектЗапроса` (хранилище структуры с данными),
   * флаг `EntityService` (через Entity/Insert/Update или кастомный REST),
   * `UIDELMA`, `ID_ELMA` и пр.
4. Обработчик:

   * достаёт записи из очереди,
   * по каждой формирует JSON,
   * вызывает **REST API ELMA**,
   * разбирает ответ,
   * пишет лог (регистры логирования, поля `КодОтвета`, `Запрос`, `Ответ`, `UIDELMA`, `ID_ELMA`).

Технически всё крутится вокруг трёх вещей:

* REST авторизация: `/API/REST/Authorization/LoginWith`
* REST сущностей: `/API/REST/Entity/...`
* Кастомные REST-ручки, чей путь лежит в `IDРесурса`.

---

## 2. Авторизация в ELMA (получение AuthToken)

### 2.1. HTTP-запрос

**Метод:** `POST`
**URL (относительный):**
`/API/REST/Authorization/LoginWith?username={username}`

В 1С формируется так:

* сервер: `ПараметрыПодключения.АдресСервера`
* порт: `ПараметрыПодключения.ПортСервера`
* путь: `"API/REST/Authorization/LoginWith?username=%login%"` → подстава логина. 

**Заголовки:**

* `Content-Type: application/json; charset=utf-8`
* `ApplicationToken: {ТокенПриложения}`

**Тело запроса:**

В тело кладут **строку с паролем**, заключённую в кавычки, то есть реально в JSON летит просто строка:

```json
"пароль_пользователя"
```

В 1С это: `Пароль = """" + ПараметрыПодключения.Пароль + """";` 

### 2.2. Ответ

* `Ответ.КодСостояния` сохраняется как `КодОтвета`.
* Тело читается как строка и дальше:

Если `Content-Type = "application/json; charset=utf-8"`:

* читается через `ЧтениеJSON`,
* преобразуется в `ОбъектXDTO`,
* из него берут `AuthToken`.

Если `Content-Type = "application/xml; charset=utf-8"`:

* читается через `ЧтениеXML`,
* тоже в `ОбъектXDTO`,
* `AuthToken` берут из того же объекта.

Если тип контента неожиданный или разбор не удался:

* `ЕстьОшибки = Истина`,
* `AuthToken = Неопределено`,
* в `ТекстОшибки` кладётся `ОписаниеОшибки()`.

В обработчике очереди при неудачной авторизации делается до **3 попыток**, дальше вываливается сообщение `"Сбой авторизации в ELMA..."`. 

---

## 3. Общие правила вызова REST-методов ELMA

### 3.1. Параметры подключения

Из доп. констант собирают структуру `ПараметрыПодключения` с полями:

* `АдресСервера`
* `ПортСервера`
* `ИмяПользователя`
* `Пароль`
* `ТокенПриложения`
* `Таймаут`
* `ИспользоватьЗащищенноеСоединение`

Этим кормят `HTTPСоединение(Сервер, Порт, ..., Таймаут, ЗащищенноеСоединение)` во всех функциях.

### 3.2. Заголовки для бизнес-запросов

Во всех запросах, где уже есть `AuthToken`, 1С ставит:

* `Content-Type: application/json; charset=utf-8`
* `AuthToken: {AuthToken}`
* `WebData-Version: 2.0` (важно именно для EntityService/WebData)

### 3.3. Тело запроса (формат JSON)

1С строит **обычную структуру** и превращает её в JSON через `ПЛ_СтруктуруВJSON`:

* для сложных типов (GUID) используется обработчик `ПреобразоватьСложныеТипыВJSON`, который делает строку из `УникальныйИдентификатор`.
* вложенные ссылки типа `{ "Uid": "..." }` задаются как встроенные структуры.

---

## 4. REST API сущностей (IEntityService)

Основной путь из модуля:

* **Insert:** `/API/REST/Entity/Insert/{typeUid}`
* **Update:** `/API/REST/Entity/Update/{typeUid}/{entityUid}`
* **Load (id → сущность):** `/API/REST/Entity/Load?type={typeUid}&id={id}`

Полный help по сервису `IEntityService` в ELMA лежит по ссылке `/API/REST/Entity/Help`.

### 4.1. Вставка сущности (Insert)

**Метод:** `POST`
**URL:** `/API/REST/Entity/Insert/{typeUid}`

В 1С:

* если `Выборка.EntityService = Истина` и `UIDELMA` **не** заполнен, берётся шаблон Insert:
  `"/API/REST/Entity/Insert/{%TYPEUID%}"`. 

**Заголовки:**

* `Content-Type: application/json; charset=utf-8`
* `AuthToken: {AuthToken}`
* `WebData-Version: 2.0`

**Тело:** JSON-объект, соответствующий полям сущности (см. дескрипторы типов ниже).

**Ответ:**

* `HTTP 200` → успешная вставка,
* тело ответа парсится, из него берут **числовой `Id`** сущности в ELMA (`ID_ELMA`),
* если нужно `Uid`, вызывают `Load` (см. 4.3).

### 4.2. Обновление сущности (Update)

**Метод:** `POST`
**URL:** `/API/REST/Entity/Update/{typeUid}/{entityUid}`

Условие выбора шаблона:

* если `EntityService = Истина` и `UIDELMA` **заполнен**, используется Update:
  `"/API/REST/Entity/Update/{%TYPEUID%}/{%ENTITYID%}"` с подстановкой `ENTITYID = UIDELMA`. 

Остальное:

* заголовки те же, что и при Insert,
* тело JSON с актуальными полями сущности,
* в логе хранят и отправленный JSON, и текст ответа.

### 4.3. Загрузка сущности / получение Uid по Id

Если ELMA вернула только **числовой Id**, а нужен GUID-Uid, используется отдельный вызов:

**Метод:** `GET` или `POST` (в 1С через `ВызватьHTTPМетод`, по сути GET)
**URL:**

```text
/API/REST/Entity/Load?type={typeUid}&id={id}
```

* `typeUid` – GUID типа (см. ниже),
* `id` – числовой идентификатор сущности в ELMA.

Из ответа `WebData` достают `Uid` и сохраняют в `UIDELMA`.

---

## 5. Описание используемых сущностей

Теперь самое любимое: поля сущностей, на которые все потом будут ругаться в отладчике.

### 5.1. Тип `Оформление приказа по организации`

**TypeUid:** `cefa63c1-5f0f-4325-8258-e46319bee2d3` 

Это основная сущность процесса приказа (в том числе на установку цен). Ключевые поля по дескриптору:

* **Id**: Int64 – внутренний id ELMA.
* **TypeUid**: Guid – UID типа.
* **Uid**: Guid – уникальный идентификатор экземпляра.
* **WorkflowInstance**: объект «Экземпляр процесса Workflow».
* **Initiator**: объект «Пользователь» (Id, Name, Uid).
* **Organization**: объект «Мои юрлица» (Id, Name, Uid).
* **Folder**: объект «Папка приказов» (Id, Name, TypeUid, Uid).
* **Decree**: объект «Приказ (Документ)» (Id, Name, TypeUid, Uid).
* **DecreeType**: объект «Типы приказов» (Id, Name, Uid).
* **Date**: дата приказа (тип «Дата/время»).
* **StartDate**: дата вступления приказа в силу (тип «Дата/время»).
* **DecreeNumber**: номер приказа (строка).
* **DecreeSubject**: тема приказа (строка).
* **Preamble**: выпадающий список (преамбула).
* **SignatoryPosition**: выпадающий список (должность подписанта).
* **CommentInitiator**: строка (комментарий инициатора).

Коллекции (табличные части сущности):

* **DecreeContents** – «Содержание приказа»

  * `Parent` – ссылка на сам приказ (Оформление приказа по организации).
  * `Uid` – Guid строки.
  * `Number` – номер пункта (строка).
  * `Content` – текст пункта (строка). 
* **ApprovementResult** – результаты согласования

  * `Parent` – приказ,
  * `Uid`,
  * `Executor` – пользователь,
  * и другие поля результата согласования. 
* **Team** – команда проекта

  * `Parent`, `Uid`,
  * `Employee` – пользователь.
* **Vedomosti** – ведомости,

  * `InventoryNumber`, `ResponsibleForWritingOff`, и т.д. (используется не только для цен, но тип общий).

Плюс множество полей под конкретные сценарии (дата участия, основные средства и т.п.) – они в дескрипторе, но не критичны для приказа на установку цен, если вы их не используете в процесс-шаблоне.

### 5.2. Тип `Типы приказов`

**TypeUid:** `70f51fc1-1c5c-4ef2-870a-c1bec8788322`

Основные поля:

* **Id**: Int64 – id в ELMA.
* **TypeUid**: Guid – UID типа.
* **Uid**: Guid – уникальный идентификатор сущности.
* **Name**: строка – наименование типа приказа.
* **Template**: файл (объект с полями `Uid`, `Name`) – шаблон документа.

Именно этот `TypeUid` подставляется в `DecreeType` у приказа.

---

## 6. Кастомные REST-ресурсы ELMA

Если поле `EntityService = Ложь`, то модуль использует **прямой путь** из `IDРесурса` и вообще не привязывается к типам сущностей ELMA:

```1c
Если Выборка.EntityService Тогда
    // Entity/Insert, Entity/Update
Иначе
    АдресРесурса = Выборка.IDРесурса;
КонецЕсли;
```

Типовые примеры из кода:

* Обновление ассортимента Min/Max по складам:
  `IdРесурса_АссортиментMinMax` хранится в доп. константах, а тело вида:

  ```json
  {
    "Warehouse": { "Uid": "..." },
    "Items": [ { "Uid": "..." }, ... ]
  }
  ```

* Остатки по складам: сущность с полями `Item.Uid`, `Warehouse.Uid`, `Balance`, `Name`, `UseInProcess`. 

Формально для описания API:

* `IDРесурса` в 1С = относительный URL REST-метода ELMA (например `/API/REST/WarehouseBalance/Update`).
* Тело JSON описывается в терминах ELMA (там уже отдельные процессы и WebData-модели).

---

## 7. Сводная табличка по основным эндпоинтам

| Цель                            | Метод | URL                                                     | Основные заголовки                                      |
| ------------------------------- | ----- | ------------------------------------------------------- | ------------------------------------------------------- |
| Авторизация, получить AuthToken | POST  | `/API/REST/Authorization/LoginWith?username={username}` | `Content-Type`, `ApplicationToken`                      |
| Вставка сущности                | POST  | `/API/REST/Entity/Insert/{typeUid}`                     | `Content-Type`, `AuthToken`, `WebData-Version: 2.0`     |
| Обновление сущности             | POST  | `/API/REST/Entity/Update/{typeUid}/{entityUid}`         | `Content-Type`, `AuthToken`, `WebData-Version: 2.0`     |
| Загрузка сущности по id         | GET   | `/API/REST/Entity/Load?type={typeUid}&id={id}`          | `AuthToken`                                             |
| Кастомный REST-метод            | POST  | `{IDРесурса}` (из доп. констант / регистра очереди)     | `Content-Type`, `AuthToken` (обычно), по договорённости |

---

## 8. Пример JSON для приказа на установку цен

Чтобы совсем уж по-человечески, пример тела, которое может лететь на `Insert` для сущности **Оформление приказа по организации** (ценовые приказы):

```json
{
  "Initiator": { "Uid": "guid-пользователя" },
  "Organization": { "Uid": "guid-юрлица" },
  "DecreeType": { "Uid": "guid-типа-приказа" },
  "Date": "2025-10-24T00:00:00",
  "StartDate": "2025-10-25T00:00:00",
  "DecreeNumber": "ПЦ-000123",
  "DecreeSubject": "Об утверждении прейскуранта цен на блюда на точке Black Sea K32",
  "Preamble": "По согласованию с ...",
  "SignatoryPosition": "Генеральный директор",
  "DecreeContents": [
    {
      "Number": "1",
      "Content": "Установить цены согласно приложению №1."
    }
  ]
}
```

Названия полей и их типы взяты из дескриптора типа `Оформление приказа по организации`.

---

Если тебе нужно, могу следом дописать это в виде отдельного блока для PRD: «Описание API ELMA», с нормальными подпунктами и сразу под твой формат документа. Но базовая картина по API у тебя теперь есть, без марафона по html-файлам.
